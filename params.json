{
  "name": "StoreBox",
  "tagline": "Android library for streamlining SharedPreferences",
  "body": "[![Build Status](https://travis-ci.org/martino2k6/StoreBox.svg)](https://travis-ci.org/martino2k6/StoreBox)\r\n[![Codacy Badge](https://api.codacy.com/project/badge/grade/b86aa22c7a8f48be9b3c3bd254710475)](https://www.codacy.com/app/martino2k6/StoreBox)\r\n[![Download](https://api.bintray.com/packages/martino2k6/maven/storebox/images/download.svg) ](https://bintray.com/martino2k6/maven/storebox/_latestVersion)\r\n[![Android Arsenal](https://img.shields.io/badge/Android%20Arsenal-StoreBox-brightgreen.svg?style=flat)](http://android-arsenal.com/details/1/1737)\r\n\r\n##Contents##\r\n* [Overview](#overview)\r\n* [Adding to a project](#adding-to-a-project)\r\n* [Interface and creation](#defining-an-interface-and-bringing-it-to-life)\r\n* [Get and set methods](#adding-get-and-set-methods)\r\n* [Defaults for get methods](#specifying-defaults-for-get-methods)\r\n* [Custom types](#storing-and-retrieving-custom-types)\r\n* [Preference types](#opening-different-types-of-preferences)\r\n* [Advanced](#advanced)\r\n * [Remove and clear methods](#remove-and-clear-methods)\r\n * [Change listeners](#change-listeners)\r\n * [Chaining calls](#chaining-calls)\r\n * [Forwarding calls](#forwarding-calls)\r\n * [Save modes](#save-modes)\r\n * [Versioning](#versioning)\r\n * [Builder & Defaults](#obtaining-a-more-customised-instance-at-run-time)\r\n * [ProGuard](#proguard)\r\n* [Contributing](#contributing)\r\n* [License](#license)\r\n\r\n##Overview##\r\nStoreBox is an annotation-based library for interacting with Android's [SharedPreferences](http://developer.android.com/reference/android/content/SharedPreferences.html), with the aim take out the the *how* and *where* parts of retrieving/storing values and instead focus on the more important *what* part.\r\n\r\nNormally when retrieving or storing values we need to know two pieces of information during each call: the key and the type.\r\n```Java\r\nString username = preferences.getString(\"key_username\", null);\r\npreferences.edit().putString(\"key_date_of_birth\", \"30/09/2004\").apply(); // should this be a String or a long?\r\n```\r\n\r\nWith StoreBox the operations above can be changed into pre-defined methods with improved semantics.\r\n```Java\r\n// definition\r\npublic interface MyPreferences {\r\n    \r\n    @KeyByString(\"key_username\")\r\n    String getUsername();\r\n    \r\n    @KeyByString(\"key_date_of_birth\")\r\n    void setDateOfBirth(String value);\r\n}\r\n\r\n// usage\r\nMyPreferences preferences = StoreBox.create(context, MyPreferences.class);\r\nString username = preferences.getUsername();\r\npreferences.setDateOfBirth(\"30/09/2004\");\r\n```\r\nThe caller now doesn't need to worry about the key, neither about what type the values are stored under. The only important part that needs to be taken into consideration is *what* is done with the values, whether that is storing them for later, showing them to the user in the UI, or just changing application behaviour.\r\n\r\nRead on to find out more details about how StoreBox can be used and how it can be added to an Android project.\r\n\r\n##Adding to a project##\r\nStoreBox can be used in Android projects using minimum SDK version 10 and newer (Android 2.3+).\r\n###JAR###\r\n[v1.4.0 JAR](https://oss.sonatype.org/service/local/repositories/releases/content/net/orange-box/storebox/storebox-lib/1.4.0/storebox-lib-1.4.0.jar)  \r\n[v1.4.0 JavaDoc JAR](https://oss.sonatype.org/service/local/repositories/releases/content/net/orange-box/storebox/storebox-lib/1.4.0/storebox-lib-1.4.0-javadoc.jar)\r\n###Gradle###\r\n```\r\ncompile 'net.orange-box.storebox:storebox-lib:1.4.0'\r\n```\r\n###Maven###\r\n```\r\n<dependency>\r\n  <groupId>net.orange-box.storebox</groupId>\r\n  <artifactId>storebox-lib</artifactId>\r\n  <version>1.4.0</version>\r\n</dependency>\r\n```\r\n\r\n##Defining an interface and bringing it to life##\r\nSimply create a new interface class in your IDE or a text editor, give it an access modifier which suits its use, and name it as appropriate.\r\n```Java\r\npublic interface MyPreferences {\r\n    \r\n}\r\n```\r\nNow you're ready to use [`StoreBox.create()`](https://github.com/martino2k6/StoreBox/blob/master/storebox-lib/src/main/java/net/orange_box/storebox/StoreBox.java) to obtain an instance.\r\n```Java\r\nMyPreferences instance = StoreBox.create(context, MyPreferences.class);\r\n```\r\n\r\n##Adding get and set methods##\r\nIf you would like to add a **getter** just add a method to the interface which returns a value and make sure to annotate it using [`@KeyByString`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/KeyByString.java) or [`@KeyByResource`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/KeyByResource.java).\r\n```Java\r\n@KeyByString(\"key_nickname\")\r\nString getNickname();\r\n\r\n@KeyByResource(R.string.key_notifications)\r\nboolean shouldShowNotifications();\r\n```\r\n\r\nAdding a **setter** is just as easy. The same annotations will need to be used as for getter methods, but now our method will return nothing and will have to provide a parameter for supplying the value that should be saved.\r\n```Java\r\n@KeyByString(\"key_nickname\")\r\nvoid setNickname(String value)\r\n\r\n@KeyByResource(R.string.key_notifications)\r\nvoid setNotifications(boolean value)\r\n```\r\n\r\n##Specifying defaults for get methods##\r\nThis can be achieved in two ways, through an argument or by using an annotation.\r\n\r\nFor the first option the following will work.\r\n```Java\r\n@KeyByString(\"key_phone_number\")\r\nString getPhoneNumber(String defValue);\r\n```\r\nAnd using an annotation referencing a default found in the XML resources.\r\n```Java\r\n@KeyByString(\"key_phone_number\")\r\n@DefaultValue(R.string.default_phone_number)\r\nString getPhoneNumber();\r\n```\r\n\r\nFor some types, such as `long`, which cannot be added to the resources an integer resource may be used instead.\r\n```Java\r\n@KeyByString(\"key_refresh_interval\")\r\n@DefaultValue(R.integer.default_refresh_interval)\r\nlong getRefreshInterval();\r\n```\r\n\r\n##Storing and retrieving custom types##\r\nSaving custom types, which are not understood by Android's SharedPreferences, can be supported through the use of type adapters. A type adapter implementation can be provided by extending from one of the following classes:\r\n* [`BaseBooleanTypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/adapters/base/BaseBooleanTypeAdapter.java) for storing as a `Boolean`\r\n* [`BaseFloatTypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/adapters/base/BaseFloatTypeAdapter.java) for storing as a `Float` and so on...\r\n* [`BaseIntegerTypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/adapters/base/BaseIntegerTypeAdapter.java)\r\n* [`BaseLongTypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/adapters/base/BaseLongTypeAdapter.java)\r\n* [`BaseStringTypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/adapters/base/BaseStringTypeAdapter.java)\r\n* [`BaseStringSetTypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/adapters/base/BaseStringSetTypeAdapter.java) (only supported on API11 and newer)\r\n\r\nTelling StoreBox which type adapter should be used can be done by adding the [`@TypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/TypeAdapter.java) annotation to the get and set methods.\r\n```Java\r\n@KeyByString(\"key_region\")\r\n@TypeAdapter(RegionTypeAdapter.class)\r\nRegion getRegion();\r\n\r\n@KeyByString(\"key_region\")\r\n@TypeAdapter(RegionTypeAdapter.class)\r\nvoid setRegion(Region value);\r\n```\r\n\r\nWhich type adapter needs to be extended depends on the use case. Take a look at the [`DateTypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/adapters/extra/DateTypeAdapter.java), [`UriTypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/adapters/extra/UriTypeAdapter.java), and [`CustomClassListTypeAdapter`](storebox-harness/src/main/java/net/orange_box/storebox/harness/types/adapters/CustomClassListTypeAdapter.java) for some examples. It is worth noting that in the last example Gson is being used for serialising the type, as opposed to writing a custom implementation. Gson is not used internally by StoreBox, as such if you wish to use Gson for a type adapter you will need to add it to your project as a dependency.\r\n\r\nThe following types will work out of the box, so type adapters don't need to be provided for them:\r\n* `Date`\r\n* `Double`\r\n* `Enum`\r\n* `Uri`\r\n\r\n*Disclaimer: APIs around type adapters may change in the future, as I will keep looking for a less verbose way of achieving the same goal without requiring the use of Gson.*\r\n\r\n##Opening different types of preferences##\r\nIn all of the examples so far details about what preferences are opened and how have been omitted.\r\n\r\nWithout any annotation the default shared preferences will be used, but the [`@DefaultSharedPreferences`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/type/DefaultSharedPreferences.java) annotation can be added to the interface definition for explicitness. Likewise, [`@ActivityPreferences`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/type/ActivityPreferences.java) or [`@FilePreferences`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/type/FilePreferences.java) can be used to respectively open preferences private to an activity or to open preferences using a file name.\r\n\r\nThe mode with which the preferences should be opened can also be specified, although this option is not supported by all the types.\r\n```Java\r\n@ActivityPreferences(mode = PreferencesMode.MULTI_PROCESS)\r\npublic interface WelcomeActivityPreferences {\r\n    \r\n    // method definitions here...\r\n}\r\n```\r\n\r\n## Advanced\r\n### Remove and clear methods\r\nIn order to remove a value stored in the preferences under a key a method to perform the removal can be annotated with the [`@RemoveMethod`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/RemoveMethod.java) annotation. The key can be supplied in two ways;\r\n\r\nThe key can be provided thorough an argument in the method, using either a `String` or an `int` in the case of the key being specified in an XML resource.\r\n```java\r\npublic interface RemoveMethodExample {\r\n    \r\n    @RemoveMethod\r\n    void remove(String key);\r\n    \r\n    @RemoveMethod\r\n    void remove(int keyRes);\r\n}\r\n\r\n// usage\r\npreferences.remove(\"key_username\");\r\npreferences.remove(R.string.key_password);\r\n```\r\n\r\nOr a value-specific remove method can be defined with the help of the [`@KeyByString`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/KeyByString.java) or [`@KeyByResource`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/KeyByResource.java) annotations.\r\n```java\r\npublic interface RemoveMethodExample {\r\n    \r\n    @KeyByString(\"key_username\")\r\n    @RemoveMethod\r\n    void removeUsername();\r\n    \r\n    @KeyByResource(R.string.key_password)\r\n    @RemoveMethod\r\n    void removePassword();\r\n}\r\n\r\n// usage\r\npreferences.removeUsername();\r\npreferences.removePassword();\r\n```\r\n\r\nClearing all values stored in the preferences can be done by annotating a method with the [`@ClearMethod`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/ClearMethod.java) annotation.\r\n```java\r\npublic interface ClearMethodExample {\r\n    \r\n    @ClearMethod\r\n    void clear();\r\n}\r\n\r\n// usage\r\npreferences.clear();\r\n```\r\n\r\n###Change listeners###\r\nCallbacks can be received when a preference value changes through the use of the [`OnPreferenceValueChangedListener`](storebox-lib/src/main/java/net/orange_box/storebox/listeners/OnPreferenceValueChangedListener.java) interface. The listeners need to be parametrised with the type which is used for the value whose changes we would like to listen for. For example, if we would like to listen to changes to the password (from previous examples) then we could define the listener as\r\n```Java\r\nOnPreferenceValueChangedListener<String> listener = new OnPreferenceValueChangedListener<String>() {\r\n    @Override\r\n    public void onChanged(String newValue) {\r\n        // do something with newValue\r\n    }\r\n}\r\n```\r\nTo register this listener a method for registering the listener would need to be defined using the [`@RegisterChangeListenerMethod`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/RegisterChangeListenerMethod.java) annotation in the interface which gets passed to [`StoreBox.create()`](storebox-lib/src/main/java/net/orange_box/storebox/StoreBox.java). Likewise, for unregistering a listener the method needs to be annotated with [`@UnregisterChangeListenerMethod`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/UnregisterChangeListenerMethod.java) instead. The [`@KeyByString`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/KeyByString.java) or [`@KeyByResource`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/KeyByResource.java) annotation also needs to be used to specify which value we are interested in.\r\n```Java\r\npublic interface ChangeListenerExample {\r\n    \r\n    @KeyByString(\"key_password\")\r\n    @RegisterChangeListenerMethod\r\n    void registerPasswordListener(OnPreferenceValueChangedListener<String> listener);\r\n    \r\n    @KeyByString(\"key_password\")\r\n    @UnregisterChangeListenerMethod\r\n    void unregisterPasswordListener(OnPreferenceValueChangedListener<String> listener);\r\n}\r\n```\r\nIf you would like to listen for changes to a custom type then the [`@TypeAdapter`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/method/TypeAdapter.java) annotation will need to be added to the method in order to tell StoreBox how the value should be adapted when retrieving it from the preferences.\r\n\r\nMore than one listener can be registered and unregistered at a time by changing the method definitions in the interface to use variable arguments.\r\n```Java\r\n// annotations omitted\r\nvoid registerPasswordListeners(OnPreferenceValueChangedListener<String>... listeners);\r\n```\r\n\r\n**Caution:** StoreBox does not store strong references to the listeners. A strong reference must be kept to the listener for as long as the listener will be required, otherwise it will be susceptible to garbage collection.\r\n\r\n###Chaining calls###\r\nWith Android's [`SharedPreferences.Editor`](http://developer.android.com/reference/android/content/SharedPreferences.Editor.html) class it is possible to keep chaining put methods as each returns back the `SharedPreferences.Editor` instance. StoreBox allows the same functionality. All that needs to be done is to change the set/remove method definitions to either return interface type itself or `SharedPreferences.Editor`.\r\n```Java\r\npublic interface ChainingExample {\r\n    \r\n    @KeyByString(\"key_username\")\r\n    ChainingExample setUsername(String value);\r\n    \r\n    @KeyByString(\"key_password\")\r\n    ChainingExample setPassword(String value);\r\n    \r\n    @KeyByString(\"key_country\")\r\n    ChainingExample removeCountry();\r\n}\r\n```\r\nAnd calls can be chained as\r\n```Java\r\npreferences.setUsername(\"Joe\").setPassword(\"jOe\").removeCountry();\r\n```\r\n\r\n###Forwarding calls###\r\nIf you would like to access methods from the [`SharedPreferences`](http://developer.android.com/reference/android/content/SharedPreferences.html) or [`SharedPreferences.Editor`](http://developer.android.com/reference/android/content/SharedPreferences.Editor.html), you can do that by extending your interface from either of the above (or even both).\r\n```Java\r\npublic interface ForwardingExample extends SharedPreferences, SharedPreferences.Editor {\r\n    \r\n    // method definitions here\r\n}\r\n```\r\nAnd the methods from either of the extended interfaces will be callable.\r\n```Java\r\nString username = preferences.getString(\"key_username\", \"\");\r\npreferences.putString(\"key_username\", \"Joe\").apply();\r\n```\r\n\r\n###Save modes###\r\nChanges to preferences can normally be saved on Android either through `apply()` or `commit()`. Which method gets used can be customised in StoreBox through the use of the [`@SaveOption`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/option/SaveOption.java) annotation.\r\n\r\nUnlike any of the previous annotations `@SaveOption` can be used to annotate both the interface as well as individual set/remove methods, however an annotation at method-level will take precedence over an interface annotation.\r\n```Java\r\n@SaveOption(SaveMode.APPLY)\r\npublic interface SaveModeExample {\r\n    // key annotations omitted\r\n    \r\n    void setUsername(String value); // will save using apply()\r\n    \r\n    @SaveOption(SaveMode.COMMIT)\r\n    void setPassword(String value); // will save using commit()\r\n    \r\n    @SaveOption(SaveMode.COMMIT)\r\n    void removeUsername(); // will persist using commit()\r\n}\r\n```\r\n\r\n###Versioning###\r\nStoreBox supports versioning of preferences through the use of the [`@PreferencesVersion`](storebox-lib/src/main/java/net/orange_box/storebox/annotations/type/PreferencesVersion.java) interface-level annotation, in a similar fashion to Android's [`SQLiteOpenHelper`](http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html). This functionality may be required in the case when the schema of the preferences needs to be changed, such as when a key or type of a preference changes, an enum constant is added/renamed/removed, or a class which is being stored in the preferences changes internally. The `@PreferencesVersion` annotation needs to be added to the interface which will be used with `StoreBox.create()`.\r\n\r\nBy default, without the `@PreferencesVersion` annotation, the version used is assumed to be `0`. The first time a change is required the `version` for the annotation should be set to `1`, with the value being incremented for any subsequent changes. To provide the logic for handling version upgrades a `handler` class extending from [`PreferencesVersionHandler`](storebox-lib/src/main/java/net/orange_box/storebox/PreferencesVersionHandler.java) needs to be specified.\r\n\r\n```Java\r\n@PreferencesVersion(version = 1, handler = MyPreferencesVersionHandler.class)\r\npublic interface MyPreferences {\r\n    \r\n    // method definitions here\r\n}\r\n\r\npublic class MyPreferencesVersionHandler extends PreferencesVersionHandler {\r\n    \r\n    @Override\r\n    protected void onUpgrade(\r\n            SharedPreferences prefs,\r\n            SharedPreferences.Editor editor,\r\n            int oldVersion,\r\n            int newVersion) {\r\n        \r\n        // logic for handling upgrades\r\n    }\r\n}\r\n```\r\n\r\nFor an initial upgrade from `0` to `1` the `onUpgrade` method will be called with `oldVersion = 0` and `newVersion = 1`. If the version of the preferences would be updated to `2`, then the handler would be called with `oldVersion = 1` and `newVersion = 2`. If however an application update using version `1` was skipped, then `onUpgrade` would be called with `oldVersion = 0` and `newVersion = 2`, which means that handling the intermediate upgrade between versions `1` and `2` would be required. Calling `apply()` or `commit()` on the `editor` is not required after changes are made, as StoreBox will take care of this when saving the new version value into the preferences. Take a look [here](storebox-harness/src/main/java/net/orange_box/storebox/harness/interfaces/versions/VersionHandler.java) for an example of how upgrades could be handled.\r\n\r\nThe versions are also independent of each other, and apply only to specific preference files. For example, you could have a shared preferences with *version X*, *activity A* preferences with *version Y*, and *activity B* preferences with *version Z*. Or none at all, if versioning is not needed.\r\n\r\n###Obtaining a more customised instance at run-time###\r\nAs previously described you can build an instance of your interface using `StoreBox.create()`, however if you'd like to override at run-time any annotations you can use [`StoreBox.Builder`](storebox-lib/src/main/java/net/orange_box/storebox/StoreBox.java) and apply different options.\r\n```Java\r\nMyPreferences preferences =\r\n        new StoreBox.Builder(context, MyPreferences.class)\r\n        .preferencesMode(PreferencesMode.MULTI_PROCESS)\r\n        .build()\r\n```\r\n\r\n###Defaults###\r\nGiven the minimum amount of details provided to the interface and method definitions through the use of StoreBox's annotations, the following defaults will get used:\r\n* Preferences type: Default shared preferences\r\n* Preferences mode: Private\r\n* Save mode: Apply\r\n* Default value mode: Empty\r\n\r\n### Proguard\r\nIf you are using ProGuard add the following lines to your configuration.\r\n```\r\n-dontwarn net.jodah.typetools.TypeResolver\r\n-keep class net.orange_box.storebox.** { *; }\r\n-keepattributes *Annotation*,Exceptions,InnerClasses,Signature\r\n\r\n```\r\n\r\n##Contributing##\r\nAny contributions thorough pull requests as well as raised issues (bugs are rated just as highly as features!) will be welcome and highly appreciated.\r\n\r\nIf you would like to submit a pull request please make sure to do so against the develop branch, and please follow a similar code style to the one used in the existing code base. Running the tests before and after any changes is highly recommended, just as is adding new test cases.\r\n\r\n###Contributors###\r\n* [cr5315](https://github.com/cr5315)\r\n\r\n##License##\r\n```\r\nCopyright 2015 Martin Bella\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n```\r\n",
  "google": "UA-33402302-4",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}